<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Sistema de notificações de acidentes rodoviários</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Leaflet GPX Plugin -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.7.0/gpx.min.js"></script>

  <style>
    #map {
      height: 90vh;
      width: 100%;
    }
  </style>
</head>
<body>

<h2 style="text-align:center">Sistema de notificações de acidentes rodoviários - EGS grupo 9</h2>
<div id="map"></div>

<script>
  // Inicializa mapa centrado em Aveiro
  const map = L.map('map').setView([40.6333, -8.6586], 15);

  // Adiciona tiles OpenStreetMap
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19
  }).addTo(map);

  // Ícones personalizados (confirma que as imagens existem no caminho)
  const icons = {
    car: L.icon({ iconUrl: '/static/icons/car.png', iconSize: [30, 30] }),
    ambulance: L.icon({ iconUrl: '/static/icons/ambulance.png', iconSize: [30, 30] }),
    crashed: L.icon({ iconUrl: '/static/icons/crash.png', iconSize: [30, 30] })
  };

  // Marcadores dos veículos no mapa
  const vehicleMarkers = {};

  // Array para guardar os pontos da rota GPX
  let gpxPoints = [];

  // Veículos a percorrer a rota, com índice inicial na rota e tipo
  const vehiclesOnRoute = [
    { id: 1, routeIndex: -1, iconType: 'car' },      // começa em -1 para avançar para 0 no update
    { id: 2, routeIndex: 9, iconType: 'car' },       // começa um pouco adiantado
    { id: 3, routeIndex: 19, iconType: 'ambulance' } // começa adiantado na rota
  ];

  // Função recursiva para extrair todos os LatLngs das layers tipo Polyline
  function extractLatLngs(layer) {
    let points = [];
    if (layer instanceof L.Polyline) {
      points = points.concat(layer.getLatLngs());
    } else if (layer._layers) {
      // É um grupo de layers, percorre recursivamente
      for (let id in layer._layers) {
        points = points.concat(extractLatLngs(layer._layers[id]));
      }
    }
    return points;
  }

  // Função que atualiza a posição dos veículos ao longo da rota
  function updateVehiclesOnRoute() {
    if (gpxPoints.length === 0) {
      console.log("Rota ainda não carregada, esperando...");
      return; // Sai se a rota ainda não carregou
    }

    vehiclesOnRoute.forEach(vehicle => {
      // Avança o índice na rota (loopando)
      vehicle.routeIndex = (vehicle.routeIndex + 1) % gpxPoints.length;

      const latlng = gpxPoints[vehicle.routeIndex];
      console.log(`Veículo ${vehicle.id} posição:`, latlng);

      if (vehicleMarkers[vehicle.id]) {
        vehicleMarkers[vehicle.id].setLatLng(latlng);
      } else {
        vehicleMarkers[vehicle.id] = L.marker(latlng, {
          icon: icons[vehicle.iconType]
        }).addTo(map);
      }
    });
  }

  // Carrega a rota GPX e, após carregar, começa o update dos veículos
  new L.GPX("/static/routes/rota_glicinias_deti.gpx", {
    async: true,
    marker_options: { startIconUrl: null, endIconUrl: null, shadowUrl: null }
  }).on('loaded', function(e) {
    map.fitBounds(e.target.getBounds());

    // Extrai todos os pontos da rota (suporta múltiplas layers e aninhamento)
    gpxPoints = extractLatLngs(e.target);

    console.log("Pontos da rota carregados:", gpxPoints.length);

    // Começa a atualizar veículos só depois da rota carregada
    setInterval(() => {
      updateVehiclesOnRoute();
    }, 1000);
  }).addTo(map);

</script>

</body>
</html>
